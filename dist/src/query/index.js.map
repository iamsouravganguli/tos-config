{
  "version": 3,
  "sources": ["../../../src/query/index.ts"],
  "sourcesContent": ["import { QueryProps, RunProps, CatchErrorProps } from \"../../index\";\nimport mongoose from \"mongoose\";\n\n/**\n * Represents a query handler class that executes queries and handles errors.\n * @template T The type of the query result.\n */\nexport class Query<T> {\n  private global?: QueryProps<T>; // Global query properties.\n  private mongoose?: typeof mongoose; // Mongoose instance\n\n  /**\n   * Creates an instance of the Query class.\n   * This constructor allows you to optionally provide global properties to be applied to all queries.\n   * @param {QueryProps<T>} [props] Optional properties to be applied globally to all queries.\n   * @example\n   * // Create a new Query instance with global error handling.\n   * const query = new Query<MyResultType>({\n   *   onError: (error) => console.error('Global error handler:', error),\n   * });\n   */\n  constructor(props?: QueryProps<T>) {\n    this.global = props;\n  }\n\n  /**\n   * Executes a query asynchronously.\n   * This method runs the specified query function and handles success, error, and \"not found\" scenarios.\n   * @param {RunProps<T>} props Properties required to run the query.\n   * @returns {Promise<void>} A Promise that resolves when the query is executed.\n   * @throws {Error} Throws an error if the model key is missing.\n   * @example\n   * // Define the run properties with a query function and error handling.\n   * const runProps: RunProps<MyResultType> = {\n   *   modelKey: MyModel,\n   *   queryFn: async (model) => await model.find({}),\n   *   onError: (error) => console.error('Query error:', error),\n   * };\n   * // Execute the query.\n   * await query.run(runProps);\n   */\n  public async run(props: RunProps<T>): Promise<void> {\n    if (!props.modelKey) {\n      throw new Error(\"Model key is required to run the query.\");\n    }\n\n    try {\n      const result = await props.queryFn(props.modelKey);\n      if (result !== null && result !== undefined) {\n        props.onSuccess?.(result);\n        this.global?.onSuccess?.(result);\n      } else {\n        props.onNotFound?.();\n        this.global?.onNotFound?.();\n      }\n    } catch (error) {\n      props.onError?.(error);\n      this.global?.onError?.(error);\n    }\n  }\n\n  /**\n   * Handles errors during query execution.\n   * This method allows you to handle errors globally or locally for a specific query.\n   * @param {CatchErrorProps} props Properties for handling errors.\n   * @example\n   * // Define the error handling properties.\n   * const catchErrorProps: CatchErrorProps = {\n   *   onError: (error) => console.error('Query execution error:', error),\n   * };\n   * // Handle errors for a specific query.\n   * query.catchError(catchErrorProps);\n   */\n  public catchError(props: CatchErrorProps): void {\n    props.onError?.(this.global?.onError);\n  }\n\n  /**\n   * Connects to the MongoDB database using Mongoose.\n   * @param {string} [dbUri] The MongoDB connection URI. If not provided, it defaults to an empty string.\n   * @param {string} [dbName] The name of the database.\n   * @returns {Promise<void>} A Promise that resolves when the connection is successful.\n   * @throws {Error} Throws an error if the connection fails.\n   * @example\n   * // Connect to MongoDB with URI and database name\n   * await query.connect(\"mongodb://localhost:27017\", \"myDatabase\");\n   * // Connect to MongoDB with only database name (uses default URI)\n   * await query.connect(undefined, \"myDatabase\");\n   */\n  public async connect(dbUri?: string, dbName?: string): Promise<void> {\n    this.mongoose = mongoose;\n    try {\n      await this.mongoose.connect(dbUri || \"\", { dbName });\n      console.log(\"Connected to MongoDB\");\n    } catch (error) {\n      console.error(`MongoDB connection error: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Disconnects from the MongoDB database.\n   * @returns {Promise<void>} A Promise that resolves when the disconnection is successful.\n   */\n  public async disconnect(): Promise<void> {\n    if (this.mongoose) {\n      try {\n        await this.mongoose.connection.close();\n        console.log(\"Disconnected from MongoDB\");\n      } catch (error) {\n        console.error(`Error closing MongoDB connection: ${error}`);\n        throw error;\n      }\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAAqB;AAMd,MAAM,MAAS;AAAA,EACZ;AAAA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYR,YAAY,OAAuB;AACjC,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,MAAa,IAAI,OAAmC;AAClD,QAAI,CAAC,MAAM,UAAU;AACnB,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAEA,QAAI;AACF,YAAM,SAAS,MAAM,MAAM,QAAQ,MAAM,QAAQ;AACjD,UAAI,WAAW,QAAQ,WAAW,QAAW;AAC3C,cAAM,YAAY,MAAM;AACxB,aAAK,QAAQ,YAAY,MAAM;AAAA,MACjC,OAAO;AACL,cAAM,aAAa;AACnB,aAAK,QAAQ,aAAa;AAAA,MAC5B;AAAA,IACF,SAAS,OAAO;AACd,YAAM,UAAU,KAAK;AACrB,WAAK,QAAQ,UAAU,KAAK;AAAA,IAC9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcO,WAAW,OAA8B;AAC9C,UAAM,UAAU,KAAK,QAAQ,OAAO;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,QAAQ,OAAgB,QAAgC;AACnE,SAAK,WAAW,gBAAAA;AAChB,QAAI;AACF,YAAM,KAAK,SAAS,QAAQ,SAAS,IAAI,EAAE,OAAO,CAAC;AACnD,cAAQ,IAAI,sBAAsB;AAAA,IACpC,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK,EAAE;AAClD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,aAA4B;AACvC,QAAI,KAAK,UAAU;AACjB,UAAI;AACF,cAAM,KAAK,SAAS,WAAW,MAAM;AACrC,gBAAQ,IAAI,2BAA2B;AAAA,MACzC,SAAS,OAAO;AACd,gBAAQ,MAAM,qCAAqC,KAAK,EAAE;AAC1D,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;",
  "names": ["mongoose"]
}
